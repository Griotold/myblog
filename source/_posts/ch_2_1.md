---
title: "혼자서 공부하는 머신러닝 + 딥러닝 ch2_1 "
author: "HS"
date: '2022-03-29'
categories: 'Python'
---

# 훈련 세트와 테스트 세트
<!-- more-->
## 지도 학습과 비지도 학습
- 지도 학습은 정답(타깃)이 있으니 알고리즘이 정답을 맞히는 것을 학습한다.
- 비지도 학습은 정답을 사용하지 않으므로 무언가를 맞힐 순 없지만, 데이터를 잘 파악하거나 변형하는 데 도움을 준다.
- 강화학습도 있다. 부록에 적어둔 책 참조.
  + 핸즈온 머신러닝 2판(한빛미디어, 2020)
  + 머신 러닝 교과서 with 파이썬, 사이킷런, 텐서플로 개정 3판(길벗, 2021)

## 훈련 세트와 테스트 세트
- 머신러닝의 성능을 제대로 평가하려면 훈련 데이터와 평가에 사용할 데이터가 각각 달라야 한다.
- 일반적으로 준비된 데이터 중에 일부는 테스트 세트로 활용하고 나머지는 훈련 세트로 활용한다.


```python
fish_length = [25.4, 26.3, 26.5, 29.0, 29.0, 29.7, 29.7, 30.0, 30.0, 30.7, 31.0, 31.0, 
                31.5, 32.0, 32.0, 32.0, 33.0, 33.0, 33.5, 33.5, 34.0, 34.0, 34.5, 35.0, 
                35.0, 35.0, 35.0, 36.0, 36.0, 37.0, 38.5, 38.5, 39.5, 41.0, 41.0, 9.8, 
                10.5, 10.6, 11.0, 11.2, 11.3, 11.8, 11.8, 12.0, 12.2, 12.4, 13.0, 14.3, 15.0]
fish_weight = [242.0, 290.0, 340.0, 363.0, 430.0, 450.0, 500.0, 390.0, 450.0, 500.0, 475.0, 500.0, 
                500.0, 340.0, 600.0, 600.0, 700.0, 700.0, 610.0, 650.0, 575.0, 685.0, 620.0, 680.0, 
                700.0, 725.0, 720.0, 714.0, 850.0, 1000.0, 920.0, 955.0, 925.0, 975.0, 950.0, 6.7, 
                7.5, 7.0, 9.7, 9.8, 8.7, 10.0, 9.9, 9.8, 12.2, 13.4, 12.2, 19.7, 19.9]
```

- 두 리스트를 하나의 리스트로 담은 2차원 리스트를 만든다.


```python
fish_data = [[l, w] for l, w in zip(fish_length, fish_weight)]
fish_target = [1]*35 + [0]*14
```

## KNeighborsClassifier 클래스
- 모델 객체 만들기 


```python
from sklearn.neighbors import KNeighborsClassifier
kn = KNeighborsClassifier()
```

- 전체 데이터에서 처음 35개를 선택
- 슬라이싱


```python
# 훈련 세트로 입력값 중 0부터 34번째 인덱스까지 사용
train_input = fish_data[:35]

# 훈련 세트로 타깃값 중 0부터 34번째 인덱스까지 사용
train_target = fish_target[:35]

# 테스트 세트로 입력값 중 35번째 부터 마지막 인덱스까지
test_input = fish_data[35:]

# 테스트 세트로 타깃값 중 35번째부터 마지막 까지
test_target = fish_target[35:]
```

### 모델 훈련


```python
kn = kn.fit(train_input, train_target)
```

### 평가


```python
kn.score(test_input, test_target)
```




    0.0



## 샘플링 편향(sampleing bias)
- 정확도가 0은 뭔가 문제가 있다는 소리.
- 마지막 14개를 테스트 세트로 놓으면 훈련 세트에는 빙어가 하나도 들어있지 않은 문제 발생.
- 골고루 섞어야 한다.

## 넘파이(numpy)
- 샘플링 편향을 막기위해 샘플을 골고루 섞어주는 라이브러리
- 파이썬의 대표적인 배열(array) 라이브러리
- 데이터를 2차원 넘파이 배열로 변환


```python
import numpy as np
```


```python
input_arr = np.array(fish_data)
target_arr = np.array(fish_target)
print(input_arr)
```

    [[  25.4  242. ]
     [  26.3  290. ]
     [  26.5  340. ]
     [  29.   363. ]
     [  29.   430. ]
     [  29.7  450. ]
     [  29.7  500. ]
     [  30.   390. ]
     [  30.   450. ]
     [  30.7  500. ]
     [  31.   475. ]
     [  31.   500. ]
     [  31.5  500. ]
     [  32.   340. ]
     [  32.   600. ]
     [  32.   600. ]
     [  33.   700. ]
     [  33.   700. ]
     [  33.5  610. ]
     [  33.5  650. ]
     [  34.   575. ]
     [  34.   685. ]
     [  34.5  620. ]
     [  35.   680. ]
     [  35.   700. ]
     [  35.   725. ]
     [  35.   720. ]
     [  36.   714. ]
     [  36.   850. ]
     [  37.  1000. ]
     [  38.5  920. ]
     [  38.5  955. ]
     [  39.5  925. ]
     [  41.   975. ]
     [  41.   950. ]
     [   9.8    6.7]
     [  10.5    7.5]
     [  10.6    7. ]
     [  11.     9.7]
     [  11.2    9.8]
     [  11.3    8.7]
     [  11.8   10. ]
     [  11.8    9.9]
     [  12.     9.8]
     [  12.2   12.2]
     [  12.4   13.4]
     [  13.    12.2]
     [  14.3   19.7]
     [  15.    19.9]]
    

- 넘파이 배열 객체는 배열의 크기를 알려주는 shape 속성을 제공한다.


```python
print(input_arr.shape) # (샘플 수, 특성 수)
```

    (49, 2)
    

- 49개의 행(샘플)
- 2개의 열(특성)

### 골고루 섞어주기
- 배열을 섞은 후에 나누는 방식 대신, 무작위로 샘플을 고르는 방법을 사용한다.
- 주의할 점은 input_arr와 target_arr에서 같은 위치는 함께 선택되어야 한다는 점이다.
- 그러려면, 훈련 세트와 테스트 세트로 나눌 인덱스값을 기억해야 한다.
- 넘파이 arange() 함수를 사용하면 0 ~ 48까지 1씩 증가하는 인덱스를 만들 수 있다.
- 그다음 이 인덱스를 골고루 섞어준다.


```python
np.random.seed(42) # 골고루 섞어줬지만, 항상 일정한 결과를 얻기 위해
index = np.arange(49)
np.random.shuffle(index)
print(index)
```

    [13 45 47 44 17 27 26 25 31 19 12  4 34  8  3  6 40 41 46 15  9 16 24 33
     30  0 43 32  5 29 11 36  1 21  2 37 35 23 39 10 22 18 48 20  7 42 14 28
     38]
    

- 골고루 섞인 인덱스를 이용해 훈련 세트와 테스트 세트로 나누자.

### 배열 인덱싱(array indexing)
- 여러 개의 인덱스로 한 번에 여러 개의 원소를 선택할 수 있다.
- 예를 들면,


```python
print(input_arr[[1, 3]])

```

    [[ 26.3 290. ]
     [ 29.  363. ]]
    

- 비슷한 방식으로 리스트 대신 넘파이 배열을 인덱스로 전달할 수 있다.


```python
train_input = input_arr[index[:35]]
train_target = target_arr[index[:35]]
```

- 만들어진 index의 첫 번째 값은 13이다. 따라서 train_input의 첫 번째 원소는 input_arr의 열네 번째 원소가 들어 있을 것이다.


```python
print(input_arr[13], train_input[0]) # 둘이 일치함을 확인
```

    [ 32. 340.] [ 32. 340.]
    

- 마찬가지로, 테스트 세트를 만들자.


```python
test_input = input_arr[index[35:]]
test_target = target_arr[index[35:]]
```

## 시각화


```python
from matplotlib import pyplot as plt
fig, ax = plt.subplots()
ax.scatter(train_input[:, 0], train_input[:, 1])
ax.scatter(test_input[:, 0], test_input[:, 1])
ax.set_xlabel('length')
ax.set_ylabel('weight')
plt.show()


```


    
![png](/images/ch_2_1/output_32_0.png)
    


- 2차원 배열은 행과 열 인덱스를 콤마(,)로 나누어 지정한다.
- 슬라이싱 연산자로 처음부터 마지막 원소까지 모두 선택하는 경우 시작과 종료 인덱스를 모두 생략할 수 있다.
- train_input[:, 0]의 의미는 행은 처음부터 마지막 원소, 열은 0열을 가져오라는 것이다.


```python
train_input
```




    array([[  32. ,  340. ],
           [  12.4,   13.4],
           [  14.3,   19.7],
           [  12.2,   12.2],
           [  33. ,  700. ],
           [  36. ,  714. ],
           [  35. ,  720. ],
           [  35. ,  725. ],
           [  38.5,  955. ],
           [  33.5,  650. ],
           [  31.5,  500. ],
           [  29. ,  430. ],
           [  41. ,  950. ],
           [  30. ,  450. ],
           [  29. ,  363. ],
           [  29.7,  500. ],
           [  11.3,    8.7],
           [  11.8,   10. ],
           [  13. ,   12.2],
           [  32. ,  600. ],
           [  30.7,  500. ],
           [  33. ,  700. ],
           [  35. ,  700. ],
           [  41. ,  975. ],
           [  38.5,  920. ],
           [  25.4,  242. ],
           [  12. ,    9.8],
           [  39.5,  925. ],
           [  29.7,  450. ],
           [  37. , 1000. ],
           [  31. ,  500. ],
           [  10.5,    7.5],
           [  26.3,  290. ],
           [  34. ,  685. ],
           [  26.5,  340. ]])



- 다시 돌아오면,
- 파란색이 훈련 세트이고, 주황색이 테스트 세트이다.
- 골고루 섞여 있음을 확인했다.

## 두 번째 머신러닝 프로그램
- KNeighborsClassifier 클래스


```python
# 모델 훈련
kn = kn.fit(train_input, train_target)
```


```python
#평가
kn.score(test_input, test_target)
```




    1.0




```python
# 예측
kn.predict(test_input)
```




    array([0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0])




```python
test_target
```




    array([0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0])



- predict() 메서드의 출력 결과가 test_target의 출력과 동일하게 array()로 감싸 있는 것을 확인한다.
- predict() 메서드가 반환하는 값은 넘파이 배열이다.
- 사실 사이킷런 모델의 입력과 출력은 모두 넘파이 배열이다.
